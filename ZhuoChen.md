2.3 Repositories
By using version control systems such as Git and Mercurial, developers can retrieve any version of files from the repositories. Git, for example, is designed to allow the collaborators access to the public repositories for any purpose by using various git commands. It also prefers illustrating the public repository by using a graph with unique committing numbers and messages for every commitment. Based on these features, it would be convenient and efficient for a team to combine and retrieve their project files in the remote repository. However, before the files are pushed into the public remote repository, there are three additional repositories, or areas that need to be accessed on the local machines; Working Tree, Stage, and History. (Chacon & Straub, 2014).
The Working Tree, Stage Area, History, and Remote repository are the main places in which developers work on their files. The Working tree is where to store and edit any necessary files and directories on the local machines. Git initialization is needed to turn a local standard directory or working tree into a git repository. After the initiation is done, all files and directories are ready to be added into Stage Area. The Stage Area is more like a rough draft or snapshot place where stores all added files are qualified to be committed into History. In the third area, History is a stage to record all of the instructions of editing and committing files from the Stage Area. In the commit process, files in the previous stage would be committed into the History repository by creating a unique SHA hash number, an author with email, a timestamp of commitment, and a committing message. Push is the last process to push the committed files into the Remote repository. In this phase, all the information of files stored in the History would be pushed into the public, which allows the collaborators to review, modify and merge these files. (Chacon & Straub, 2014)
3.1 Branching
Branch in Git is a pointer that always points to the last commit, as long as the user commits the files on the same branch. After the first time committing the files, Git automatically creates the first branch named “master” for the users. Like many programming languages, users can create multiple branch pointers with different names. To distinguish different branches, Git uses HEAD as a special pointer that points to the checked-out branch. Branches can then be checked out, which changes the HEAD to point to the desired branch. (Chacon & Straub, 2014)
Based on these features, the branch allows the developer to work on different versions of the same files synchronously, which results in a separation of versions of these files. The developers are also allowed to merge branches. In this way, branches are capable of handling different purposes of operations. For instance, to raise productivity, a project can have a production branch, development branch, and debug branch for the same source files in which developers can work in parallel.
As shown in Figure 3.1, in addition to the instructions mentioned in the previous section, it also explains the steps of merging and retrieving the files from remote repositories. Firstly the process of pulling is required to fetch the desired files from public repositories to the local History repository. After this stage, developers can checkout any previous versions of committed files for both the staging area and working tree or merge the fetched files.

